<!--suppress ALL -->
<div class="row">
    <h3 class="col-sm-2">診察</h3>
    <div class="col-sm-10">
        <button class="btn btn-secondary" id="practice-choose-patient-button">患者選択</button>
    </div>
</div>

<div class="modal x-dialog" tabindex="-1" role="dialog" data-backdrop="true"
     id="practice-choose-patient-dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">患者選択</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="x-search_">
                    <form class="form-inline x-form">
                        <input class="form-control x-input"/>
                        <button type="submit" class="form-control ml-2">検索</button>
                    </form>
                    <select class="form-control mt-2 form-control x-select" size="5"></select>
                </div>
                <div class="card mt-2">
                    <div class="card-body">
                        <div class="row x-display_">
                            <div class="col-sm-3">患者番号</div>
                            <div class="col-sm-9 x-patient-id"></div>
                            <div class="col-sm-3">氏名</div>
                            <div class="col-sm-9">
                                <span class="x-last-name"></span><span
                                    class="x-first-name"></span>
                            </div>
                            <div class="col-sm-3">よみ</div>
                            <div class="col-sm-9 x-yomi">
                                <span class="x-last-name-yomi"></span><span
                                    class="x-first-name-yomi"></span>
                            </div>
                            <div class="col-sm-3">生年月日</div>
                            <div class="col-sm-9">
                                <span class="x-birthday"></span>
                                <span class="x-age"></span>
                            </div>
                            <div class="col-sm-3">性別</div>
                            <div class="col-sm-9 x-sex"></div>
                            <div class="col-sm-3">住所</div>
                            <div class="col-sm-9 x-address"></div>
                            <div class="col-sm-3">電話</div>
                            <div class="col-sm-9 x-phone"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary x-register-enter">受付・選択</button>
                <button type="button" class="btn btn-primary x-enter">選択</button>
                <button type="button" class="btn btn-secondary x-cancel">キャンセル</button>
            </div>
        </div>
    </div>
</div>

<div id="practice-patient-info" class="d-none mx-2">
    [<span class="x-patient-id"></span>]
    <span class="x-last-name"></span><span class="x-first-name"></span>
    (<span class="x-last-name-yomi"></span><span class="x-first-name-yomi"></span>)
    <span class="x-birthday"></span>生
    (<span class="x-age"></span>才)
    <span class="x-sex"></span>性
    <button type="button" class="x-detail-link btn btn-link">詳細</button>
    <div class="x-detail d-none row">
        <div class="col-sm-3">住所</div>
        <div class="x-address col-sm-9"></div>
        <div class="col-sm-3">電話番号</div>
        <div class="x-phone col-sm-9"></div>
    </div>
</div>

<div id="practice-record-wrapper"></div>

<template id="practice-record-template">
    <div>
        <div class="x-title"></div>
        <div class="row">
            <div class="x-left_ col-sm-6 rp-1">
                <div class="x-text-wrapper"></div>
                <div class="x-command-wrapper">
                    <button type="button" class="btn btn-link x-enter-text">[文章入力]</button>
                </div>
            </div>
            <div class="x-right_ col-sm-6 lp-1">
                <div class="x-hoken-wrapper"></div>
                <button type="button" class="btn btn-link x-shinryou-menu">[診療行為]</button>
                <div class="x-shinryou-wrapper"></div>
                <button type="button" class="btn btn-link x-shochi-menu">[処置]</button>
                <div class="x-shochi-wrapper"></div>
            </div>
        </div>
    </div>
</template>

<template id="practice-title-template">
    <div class="mt-2"></div>
</template>

<template id="practice-hoken-template">
    <div></div>
</template>

<template id="practice-text-template">
    <div class="my-1"></div>
</template>

<template id="practice-enter-text-template">
    <div class="mt-2">
        <textarea class="form-control x-textarea" rows="6"></textarea>
        <div class="form-inline">
            <button type="button" class="btn btn-link x-enter">入力</button>
            <button type="button" class="btn btn-link x-cancel">キャンセル</button>
        </div>
    </div>
</template>

<template id="practice-edit-text-template">
    <div class="mt-2">
        <textarea class="form-control x-textarea" rows="6"></textarea>
        <div class="form-inline">
            <button type="button" class="btn btn-link x-enter">入力</button>
            <button type="button" class="btn btn-link x-cancel">キャンセル</button>
            <button type="button" class="btn btn-link x-delete">削除</button>
            <button type="button" class="btn btn-link x-shohousen">処方箋発行</button>
            <button type="button" class="btn btn-link x-shohousen-fax">処方箋FAX</button>
            <button type="button" class="btn btn-link x-copy">コピー</button>
        </div>
    </div>
</template>

<template id="practice-shohousen-preview-dialog-template">
    <div class="modal" tabindex="-1" role="dialog" data-backdrop="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">処方箋</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="x-disp" style="width:148mm;height:210mm"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary x-print">印刷</button>
                    <button type="button" class="btn btn-secondary x-close">閉じる</button>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
    function hyphenToCamel(s) {
        let ps = s.split(/-+/);
        for (let i = 1; i < ps.length; i++) {
            let p = ps[i];
            ps[i] = p[0].toUpperCase() + p.substring(1);
        }
        return ps.join("");
    }

    function probeXClass(e) {
        let attrClass = e.attr("class");
        if (attrClass) {
            for (let cls of attrClass.split(/\s+/)) {
                if (cls.startsWith("x-")) {
                    e.removeClass(cls);
                    return hyphenToCamel(cls.substring(2));
                }
            }
        }
        return null;
    }

    function parseElementIter(ele, map) {
        ele = $(ele);
        if (ele.length === 1) {
            let name = probeXClass(ele);
            if (name) {
                map[name] = ele;
                if (name.endsWith("_")) {
                    name = name.substring(0, name.length - 1);
                    let submap = {};
                    parseElementIter(ele.children(), submap);
                    map[name] = submap;
                } else {
                    parseElementIter(ele.children(), map);
                }
            } else {
                parseElementIter(ele.children(), map);
            }
        } else {
            for (let e of ele.toArray()) {
                parseElementIter(e, map);
            }
        }
    }

    function parseElement(ele) {
        let map = {};
        parseElementIter(ele, map);
        return map;
    }

    function getTemplateHtml(templateId) {
        let html = $("template#" + templateId).html();
        if (!html) {
            console.error(`cannot find "${templateId}"`);
        }
        return html;
    }

    function assert(value) {
        if (!value) {
            throw new Error("assetion failed.");
        }
    }

    (async function () {
        let modChoosePatientDialog = await import("./practice/choose-patient-dialog.js");
        let modPatientDisplay = await import("./practice/patient-display.js");
        let modDrawerSvg = await import("./js/drawer-svg.js");

        let choosePatientDialog = (function () {
            let ele = $("#practice-choose-patient-dialog");
            let map = parseElement(ele);
            return new modChoosePatientDialog.ChoosePatientDialog(map, rest);
        })();

        class PatientInfo {
            constructor(ele, map) {
                this.ele = ele;
                this.map = map;
                this.detail = map.detail;
                map.detailLink.on("click", event => this.toggleDetail());
                this.display = new modPatientDisplay.PatientDisplay(map);
            }

            setPatient(patient) {
                this.display.setPatient(patient);
            }

            show() {
                this.ele.removeClass("d-none");
            }

            hide() {
                this.ele.addClass("d-none");
            }

            showDetail() {
                this.detail.removeClass("d-none");
            }

            hideDetail() {
                this.detail.addClass("d-none");
            }

            toggleDetail() {
                if (this.detail.hasClass("d-none")) {
                    this.showDetail();
                } else {
                    this.hideDetail();
                }
            }
        }

        let patientInfo = (function () {
            let ele = $("#practice-patient-info");
            let map = parseElement(ele);
            return new PatientInfo(ele, map);
        })();

        class Record {
            constructor(ele, map, titleFactory, textFactory, hokenFactory) {
                this.ele = ele;
                this.titleElement = map.title;
                this.enterTextElement = map.left.enterText;
                this.textWrapperElement = map.left.textWrapper;
                this.rightElement = map.right_;
                this.hokenWrapperElement = map.right.hokenWrapper;
                this.shinryouMenuElement = map.right.shinryouMenu;
                this.shinryouWrapperElement = map.right.shinryouWrapper;
                this.shochiMenuElement = map.right.shochiMenu;
                this.shochiWrapperElement = map.right.shochiWrapper;
                this.titleFactory = titleFactory;
                this.textFactory = textFactory;
                this.hokenFactory = hokenFactory;
                this.shinryouMenuElement.on("click", event => console.log("Shinryou Menu"));
                this.shochiMenuElement.on("click", event => console.log("Shochi Menu"));
            }

            async init(visitFull) {
                this.visitFull = visitFull;
                let visit = visitFull.visit;
                this.titleFactory.create(visit).appendTo(this.titleElement);
                for (let text of visitFull.texts) {
                    let comp = this.textFactory.create(text);
                    comp.appendTo(this.textWrapperElement);
                }
                let hoken = await this.hokenFactory.create(visitFull.hoken);
                hoken.appendTo(this.hokenWrapperElement);
            }

            bindToEnterTextElement(enterTextFactory) {
                let visit = this.visitFull.visit;
                this.enterTextElement.on("click", event => {
                    let comp = enterTextFactory.create(visit.visitId);
                    comp.onCancel(event => comp.remove());
                    comp.onEntered((event, text) => {
                        let factory = new TextFactory();
                        let newComp = factory.create(text);
                        newComp.appendTo(this.textWrapperElement);
                        comp.remove();
                    });
                    this.enterTextElement.before(comp.ele);
                });
            }

            appendTo(element) {
                element.append(this.ele);
            }
        }

        class RecordFactory {
            constructor() {
                this.html = getTemplateHtml("practice-record-template");
                this.rest = rest;
            }

            async create(visitFull) {
                let ele = $(this.html);
                let map = parseElement(ele);
                let record = new Record(ele, map, new TitleFactory(), new TextFactory(),
                    new HokenFactory());
                await record.init(visitFull);
                record.bindToEnterTextElement(new EnterTextFactory());
                return record;
            }
        }

        class Title {
            constructor(ele, visit) {
                this.ele = ele;
                this.ele.text(this.rep(visit.visitedAt));
            }

            rep(sqldatetime) {
                let data = kanjidate.sqldatetimeToData(sqldatetime);
                let nen = (data.nen + "").padStart(2, "0");
                let month = (data.month + "").padStart(2, "0");
                let day = (data.day + "").padStart(2, "0");
                let hour = (data.hour + "").padStart(2, "0");
                let minute = (data.minute + "").padStart(2, "0");
                return `${data.gengou.name}${nen}年${month}月${day}日（${data.youbi}） ${hour}時${minute}分`;
            }

            appendTo(element) {
                element.append(this.ele);
            }
        }

        class TitleFactory {
            constructor() {
                this.html = $("template#practice-title-template").html();
            }

            create(visit) {
                let ele = $(this.html);
                return new Title(ele, visit);
            }
        }

        class Component {
            constructor(ele, map, rest) {
                this.ele = ele;
                this.map = map;
                this.rest = rest;
            }

            appendTo(element) {
                element.append(this.ele);
            }

            remove() {
                this.ele.remove();
            }

            putBefore(element) {
                element.before(this.ele);
            }

            replace(element) {
                element.after(this.ele);
                element.detach();
            }
        }

        class Text extends Component {
            constructor(ele, map, rest) {
                super(ele, map, rest);
            }

            init(text) {
                this.ele.html(text.content.replace(/\r\n|\n|\r/g, "<br/>\n"));
                let self = this;
                this.ele.on("click", event => {
                    let editTextFactory = new EditTextFactory();
                    let compEdit = editTextFactory.create(text);
                    compEdit.onCancel(event => self.replace(compEdit.ele));
                    compEdit.onUpdated((event, updatedText) => {
                        let textFactory = new TextFactory();
                        let compUpdatedText = textFactory.create(updatedText);
                        compUpdatedText.replace(compEdit.ele);
                    });
                    compEdit.onDeleted(event => compEdit.remove());
                    compEdit.replace(this.ele);
                });
            }
        }

        class TextFactory {
            constructor() {
                this.html = $("template#practice-text-template").html();
                this.rest = rest;
            }

            create(text) {
                let ele = $(this.html);
                let map = parseElement(ele);
                let comp = new Text(ele, map, this.rest);
                comp.init(text);
                return comp;
            }
        }

        class Hoken {
            constructor(ele, map, hoken, hokenRep) {
                this.ele = ele;
                this.hoken = hoken;
                this.ele.text(hokenRep);
            }

            appendTo(element) {
                element.append(this.ele);
            }
        }

        class HokenFactory {
            constructor() {
                this.html = getTemplateHtml("practice-hoken-template");
                this.rest = rest;
            }

            async create(hoken) {
                let ele = $(this.html);
                let map = parseElement(ele);
                let hokenRep = await this.rest.hokenRep(hoken);
                if (hokenRep === "") {
                    hokenRep = "[保険なし]";
                }
                return new Hoken(ele, map, hoken, hokenRep);
            }
        }

        class EnterText extends Component {
            constructor(ele, map, rest) {
                super(ele, map, rest);
                this.textAreaElement = map.textarea;
                this.enterElement = map.enter;
                this.cancelElement = map.cancel;
                assert(this.textAreaElement && this.enterElement && this.cancelElement);
            }

            setVisitId(visitId) {
                this.visitId = visitId;
                this.enterElement.on("click", event => this.doEnter());
                this.cancelElement.on("click", event => {
                    this.ele.trigger("cancel");
                });
            }

            async doEnter() {
                assert(this.visitId > 0);
                let content = this.textAreaElement.val();
                let text = {
                    content: content,
                    visitId: this.visitId
                };
                let textId = await rest.enterText(text);
                let entered = await rest.getText(textId);
                this.ele.trigger("onEntered", entered);
            }

            onEntered(cb) {
                this.ele.on("onEntered", cb);
            }

            onCancel(cb) {
                this.ele.on("cancel", cb);
            }
        }

        class EnterTextFactory {
            constructor() {
                this.html = getTemplateHtml("practice-enter-text-template");
                this.rest = rest;
            }

            create(visitId) {
                let ele = $(this.html);
                let map = parseElement(ele);
                let comp = new EnterText(ele, map, this.rest);
                comp.setVisitId(visitId);
                return comp;
            }
        }

        class EditText extends Component {
            constructor(ele, map, rest) {
                super(ele, map, rest);
                this.textareaElement = map.textarea;
                this.enterElement = map.enter;
                this.cancelElement = map.cancel;
                this.deleteElement = map.delete;
                this.shohousenElement = map.shohousen;
                this.shohousenFaxElement = map.shohousenFax;
                this.copyElement = map.copy;
            }

            init(text) {
                this.text = text;
                this.textareaElement.val(text.content);
                this.enterElement.on("click", event => this.doEnter());
                this.cancelElement.on("click", event => this.ele.trigger("cancel"));
                this.deleteElement.on("click", event => this.doDelete());
                this.shohousenElement.on("click", event => this.doShohousen());
                this.shohousenFaxElement.on("click", event => this.doShohousenFax());
                this.copyElement.on("click", event => this.doCopy());
            }

            async createShohousenOps(reqOpts) {
                let visit = await this.rest.getVisit(this.text.visitId);
                let req = {};
                req.clinicInfo = await this.rest.getClinicInfo();
                req.hoken = await this.rest.getHoken(this.text.visitId);
                req.patient = await this.rest.getPatient(visit.patientId);
                let rcptAge = await this.rest.calcRcptAge(req.patient.birthday,
                    visit.visitedAt.substring(0, 10));
                req.futanWari = await this.rest.calcFutanWari(req.hoken, rcptAge);
                req.drugs = this.text.content;
                Object.assign(req, reqOpts);
                let ops = await this.rest.shohousenDrawer(req);
                return ops;
            }

            async doShohousen() {
                let ops = await this.createShohousenOps();
                let result = await shohousenPreviewController.open(ops);
                this.ele.trigger("cancel");
            }

            async doShohousenFax() {
                if (confirm("この処方箋をPDFとして保存しますか？")) {
                    let visit = await this.rest.getVisit(this.text.visitId);
                    let patient = await this.rest.getPatient(visit.patientId);
                    let name = await this.rest.convertToRomaji(patient.lastNameYomi + patient.firstNameYomi);
                    let savePath = await this.rest.getShohousenSavePdfPath(name, this.text.textId,
                        patient.patientId, visit.visitedAt.substring(0, 10));
                    let stampInfo = await this.rest.shohousenGrayStampInfo();
                    let ops = await this.createShohousenOps({color: "black"});
                    await this.rest.saveDrawerAsPdf([ops], "A5", savePath, {stamp: stampInfo});
                    this.ele.trigger("cancel");
                }
            }

            doCopy() {
                console.log("doCopy");
            }

            async doEnter() {
                let content = this.textareaElement.val();
                let text = Object.assign({}, this.text, {content: content});
                assert(text.textId > 0);
                assert(text.visitId > 0);
                await this.rest.updateText(text);
                let updatedText = await this.rest.getText(text.textId);
                this.ele.trigger("updated", updatedText);
            }

            async doDelete() {
                if (confirm("本当にこの文章を削除していいですか？")) {
                    let textId = this.text.textId;
                    assert(textId > 0);
                    await this.rest.deleteText(textId);
                    this.ele.trigger("deleted");
                }
            }

            onDeleted(cb) {
                this.ele.on("deleted", cb);
            }

            onUpdated(cb) {
                this.ele.on("updated", cb);
            }

            onCancel(cb) {
                this.ele.on("cancel", cb);
            }
        }

        class EditTextFactory {
            constructor() {
                this.html = getTemplateHtml("practice-edit-text-template");
                this.rest = rest;
            }

            create(text) {
                let ele = $(this.html);
                let map = parseElement(ele);
                let comp = new EditText(ele, map, this.rest);
                comp.init(text);
                return comp;
            }
        }

        class ShohousenPreviewController {
            constructor(html, rest) {
                this.html = html;
                this.rest = rest;
            }

            async open(ops) {
                let ele = $(this.html);
                let map = parseElement(ele);
                let printElement = map.print;
                let closeElement = map.close;
                let svg = modDrawerSvg.drawerToSvg(ops,
                    {width: "148mm", height: "210mm", viewBox: "0 0 148 210"});
                map.disp.append(svg);
                return new Promise(resolve => {
                    printElement.on("click", async event => {
                        await this.rest.printDrawer([ops]);
                        ele.modal("hide");
                        resolve(true);
                    });
                    closeElement.on("click", event => {
                        ele.modal("hide");
                        resolve(null);
                    });
                    ele.modal("show");
                });
            }
        }

        let shohousenPreviewController = new ShohousenPreviewController(
            getTemplateHtml("practice-shohousen-preview-dialog-template"),
            rest
        );

        $("#practice-choose-patient-button").on("click", async event => {
            let result = await choosePatientDialog.open();
            if (result.mode === "enter" || result.mode === "registerEnter") {
                let recordWrapperElement = $("#practice-record-wrapper").html("");
                let patient = result.patient;
                patientInfo.setPatient(patient);
                patientInfo.show();
                let page = await rest.listVisit(patient.patientId, 0);
                let recordFactory = new RecordFactory();
                for (let visitFull of page.visits) {
                    let record = await recordFactory.create(visitFull);
                    record.appendTo(recordWrapperElement);
                }
            }
        });

    })();

</script>